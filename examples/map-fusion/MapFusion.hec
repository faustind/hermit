binding-of 'map
set-pp-type "Omit"
top
rule-to-lemma "map-fusion"
prove-lemma "map-fusion"
-- forall f g.  map f . map g = map (f . g)
extensionality 'xs
-- forall f g xs.  (map f . map g) xs = map (f . g) xs
lhs (unfold '.)
-- forall f g xs.  map f (map g xs) = map (f . g) xs
induction 'xs


-- Case undefined
   -- forall f g.  map f (map g undefined) = map (f . g) undefined
   { foralls-body
     { conj-lhs
       rhs (unfold 'map)

       -- forall f g.
       --      map f (map g undefined)
       --   =
       --      case undefined of
       --        []   -> []
       --        a:as -> (f . g) a : map (f . g) as
       rhs undefined-case


       -- forall f g.  map f (map g undefined) = undefined
       lhs (any-bu (unfold 'map >>> undefined-case))
       reflexivity
     }

     -- Case []
     { conj-rhs
       conj-lhs
        -- forall f g.  map f (map g []) = map (f . g) []

        both (any-bu (unfold 'map >>> case-reduce))
        reflexivity
     }

    -- Case (:)
    { conj-rhs
      conj-rhs
      -- induction hypothesis: map f (map g ys) = map (f . g) ys

      -- forall f g.  map f (map g (y:ys)) = map (f . g) (y:ys)
      both (any-bu (unfold 'map >>> case-reduce))

      -- forall f g.  f (g y) : map f (map g ys) = (f . g) y : map (f . g) ys
      rhs (one-td (lemma-backward ind-hyp-0))

      -- forall f g.  f (g y) : map f (map g ys) = (f . g) y : map f (map g ys)
      rhs (one-td (unfold '.))
   }
   end-proof

-- Successfully proven
